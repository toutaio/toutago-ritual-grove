package storage

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"gopkg.in/yaml.v3"
)

// State represents the deployment state of a ritual-generated project.
type State struct {
	RitualName        string      `yaml:"ritual_name"`
	RitualVersion     string      `yaml:"ritual_version"`
	InstalledAt       time.Time   `yaml:"installed_at"`
	UpdatedAt         time.Time   `yaml:"updated_at,omitempty"`
	AppliedMigrations []Migration `yaml:"applied_migrations"`
	GeneratedFiles    []string    `yaml:"generated_files"`
	ProtectedFiles    []string    `yaml:"protected_files"`
}

// Migration represents a database or code migration that has been applied.
type Migration struct {
	Version   string    `yaml:"version"`
	AppliedAt time.Time `yaml:"applied_at"`
	ServerID  string    `yaml:"server_id,omitempty"`
}

// Save saves the state to .ritual/state.yaml in the project directory.
func (s *State) Save(projectPath string) error {
	stateDir := filepath.Join(projectPath, ".ritual")
	if err := os.MkdirAll(stateDir, 0750); err != nil {
		return fmt.Errorf("failed to create state directory: %w", err)
	}

	statePath := filepath.Join(stateDir, "state.yaml")
	data, err := yaml.Marshal(s)
	if err != nil {
		return fmt.Errorf("failed to marshal state: %w", err)
	}

	if err := os.WriteFile(statePath, data, 0600); err != nil {
		return fmt.Errorf("failed to write state file: %w", err)
	}

	return nil
}

// LoadState loads the state from .ritual/state.yaml in the project directory.
func LoadState(projectPath string) (*State, error) {
	statePath := filepath.Join(projectPath, ".ritual", "state.yaml")
	// #nosec G304 - statePath is constructed from validated components
	data, err := os.ReadFile(statePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read state file: %w", err)
	}

	var state State
	if err := yaml.Unmarshal(data, &state); err != nil {
		return nil, fmt.Errorf("failed to unmarshal state: %w", err)
	}

	return &state, nil
}

// AddMigration adds a migration to the applied migrations list.
func (s *State) AddMigration(version string) {
	s.AppliedMigrations = append(s.AppliedMigrations, Migration{
		Version:   version,
		AppliedAt: time.Now(),
	})
}

// IsMigrationApplied checks if a specific migration version has been applied.
func (s *State) IsMigrationApplied(version string) bool {
	for _, m := range s.AppliedMigrations {
		if m.Version == version {
			return true
		}
	}
	return false
}

// MarkFileAsGenerated marks a file as generated by the ritual.
func (s *State) MarkFileAsGenerated(file string) {
	// Check if already marked
	for _, f := range s.GeneratedFiles {
		if f == file {
			return
		}
	}
	s.GeneratedFiles = append(s.GeneratedFiles, file)
}

// MarkFileAsProtected marks a file as protected (should not be overwritten).
func (s *State) MarkFileAsProtected(file string) {
	// Check if already marked
	for _, f := range s.ProtectedFiles {
		if f == file {
			return
		}
	}
	s.ProtectedFiles = append(s.ProtectedFiles, file)
}

// IsFileGenerated checks if a file was generated by the ritual.
func (s *State) IsFileGenerated(file string) bool {
	for _, f := range s.GeneratedFiles {
		if f == file {
			return true
		}
	}
	return false
}

// IsFileProtected checks if a file is marked as protected.
func (s *State) IsFileProtected(file string) bool {
	for _, f := range s.ProtectedFiles {
		if f == file {
			return true
		}
	}
	return false
}
