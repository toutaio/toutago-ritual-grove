package helpers

import (
	"testing"
)

func TestValidatePasswordStrength_Valid(t *testing.T) {
	validPasswords := []string{
		"SecureP@ss123",
		"MyP@ssw0rd!",
		"Str0ng#Password",
		"C0mpl3x!Pass",
		"Passw0rd@123",
	}

	for _, password := range validPasswords {
		err := ValidatePasswordStrength(password)
		if err != nil {
			t.Errorf("Password %q should be valid, got error: %v", password, err)
		}
	}
}

func TestValidatePasswordStrength_TooShort(t *testing.T) {
	shortPasswords := []string{
		"Pass1!",
		"Ab1@",
		"12345",
	}

	for _, password := range shortPasswords {
		err := ValidatePasswordStrength(password)
		if err == nil {
			t.Errorf("Password %q should fail (too short)", password)
		}
		if err != nil && err.Error() != "password must be at least 8 characters long" {
			t.Errorf("Expected 'too short' error, got: %v", err)
		}
	}
}

func TestValidatePasswordStrength_NoUppercase(t *testing.T) {
	passwords := []string{
		"password123!",
		"myp@ssw0rd",
		"lowercase1!",
	}

	for _, password := range passwords {
		err := ValidatePasswordStrength(password)
		if err == nil {
			t.Errorf("Password %q should fail (no uppercase)", password)
		}
		if err != nil && err.Error() != "password must contain at least one uppercase letter" {
			t.Errorf("Expected 'no uppercase' error, got: %v", err)
		}
	}
}

func TestValidatePasswordStrength_NoLowercase(t *testing.T) {
	passwords := []string{
		"PASSWORD123!",
		"MYP@SSW0RD",
		"UPPERCASE1!",
	}

	for _, password := range passwords {
		err := ValidatePasswordStrength(password)
		if err == nil {
			t.Errorf("Password %q should fail (no lowercase)", password)
		}
		if err != nil && err.Error() != "password must contain at least one lowercase letter" {
			t.Errorf("Expected 'no lowercase' error, got: %v", err)
		}
	}
}

func TestValidatePasswordStrength_NoDigit(t *testing.T) {
	passwords := []string{
		"Password!",
		"MyP@ssword",
		"NoDigits!",
	}

	for _, password := range passwords {
		err := ValidatePasswordStrength(password)
		if err == nil {
			t.Errorf("Password %q should fail (no digit)", password)
		}
		if err != nil && err.Error() != "password must contain at least one digit" {
			t.Errorf("Expected 'no digit' error, got: %v", err)
		}
	}
}

func TestValidatePasswordStrength_NoSpecialChar(t *testing.T) {
	passwords := []string{
		"Password123",
		"MyPassw0rd",
		"NoSpecial1",
	}

	for _, password := range passwords {
		err := ValidatePasswordStrength(password)
		if err == nil {
			t.Errorf("Password %q should fail (no special char)", password)
		}
		if err != nil && err.Error() != "password must contain at least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)" {
			t.Errorf("Expected 'no special char' error, got: %v", err)
		}
	}
}

func TestValidatePasswordStrength_CommonPasswords(t *testing.T) {
	commonPasswords := []string{
		"Password123!",
		"Admin123!",
		"Welcome123!",
		"Qwerty123!",
		"Letmein123!",
	}

	for _, password := range commonPasswords {
		err := ValidatePasswordStrength(password)
		if err == nil {
			t.Errorf("Password %q should fail (too common)", password)
		}
		if err != nil && err.Error() != "password is too common, please choose a more unique password" {
			t.Errorf("Expected 'too common' error, got: %v", err)
		}
	}
}

func TestValidatePasswordStrength_EdgeCases(t *testing.T) {
	tests := []struct {
		name     string
		password string
		wantErr  bool
	}{
		{
			name:     "Exactly 8 chars valid",
			password: "Pass1@rd",
			wantErr:  false,
		},
		{
			name:     "Very long password",
			password: "ThisIsAVeryLongP@ssw0rdThatShouldStillBeValid123456789!",
			wantErr:  false,
		},
		{
			name:     "Multiple special chars",
			password: "P@$$w0rd!#%",
			wantErr:  false,
		},
		{
			name:     "Empty password",
			password: "",
			wantErr:  true,
		},
		{
			name:     "Only spaces",
			password: "        ",
			wantErr:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidatePasswordStrength(tt.password)
			if (err != nil) != tt.wantErr {
				t.Errorf("ValidatePasswordStrength() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestGetPasswordStrengthScore_Weak(t *testing.T) {
	weakPasswords := []string{
		"password",
		"12345678",
		"abcdefgh",
	}

	for _, password := range weakPasswords {
		score := GetPasswordStrengthScore(password)
		if score > 2 {
			t.Errorf("Password %q should have weak score (<= 2), got %d", password, score)
		}
	}
}

func TestGetPasswordStrengthScore_Medium(t *testing.T) {
	mediumPasswords := []string{
		"Password123",
		"Mypass123",
	}

	for _, password := range mediumPasswords {
		score := GetPasswordStrengthScore(password)
		if score < 2 || score > 3 {
			t.Errorf("Password %q should have medium score (2-3), got %d", password, score)
		}
	}
}

func TestGetPasswordStrengthScore_Strong(t *testing.T) {
	strongPasswords := []string{
		"SecureP@ss123",
		"MyP@ssw0rd!",
		"Str0ng#Password",
	}

	for _, password := range strongPasswords {
		score := GetPasswordStrengthScore(password)
		if score < 4 {
			t.Errorf("Password %q should have strong score (>= 4), got %d", password, score)
		}
	}
}
