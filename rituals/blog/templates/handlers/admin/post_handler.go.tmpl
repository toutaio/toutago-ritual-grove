package admin

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"[[.module_path]]/internal/domain"
	"[[.module_path]]/internal/dto"
	"[[.module_path]]/internal/services"
	"github.com/toutaio/toutago-cosan-router"
)

// PostAdminHandler handles admin post management operations
type PostAdminHandler struct {
	postService services.PostService
	permService services.PermissionService
}

// NewPostAdminHandler creates a new PostAdminHandler
func NewPostAdminHandler(postService services.PostService, permService services.PermissionService) *PostAdminHandler {
	return &PostAdminHandler{
		postService: postService,
		permService: permService,
	}
}

// List shows all posts for admin (with filters)
func (h *PostAdminHandler) List(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Check permission
	if !h.permService.Can(currentUser, "manage", "posts") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to manage posts",
		})
		return
	}

	// Parse query parameters
	filters := dto.PostFilters{
		Page:  getQueryInt(ctx, "page", 1),
		Limit: getQueryInt(ctx, "limit", 20),
	}

	// Filter by status if provided
	if status := ctx.Query("status"); status != "" {
		s := domain.PostStatus(status)
		filters.Status = &s
	}

	// Filter by category if provided
	if categoryID := ctx.Query("category_id"); categoryID != "" {
		if id, err := strconv.ParseInt(categoryID, 10, 64); err == nil {
			filters.CategoryID = &id
		}
	}

	// Authors can only see their own posts
	if currentUser.Role == domain.RoleAuthor {
		filters.AuthorID = &currentUser.ID
	}

	// Get posts
	posts, total, err := h.postService.List(filters)
	if err != nil {
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to fetch posts",
		})
		return
	}

	// Calculate pagination
	totalPages := (total + filters.Limit - 1) / filters.Limit

	// Return response
	ctx.Status(http.StatusOK).JSON(map[string]interface{}{
		"posts":       posts,
		"total":       total,
		"page":        filters.Page,
		"limit":       filters.Limit,
		"total_pages": totalPages,
		"can_create":  h.permService.Can(currentUser, "create", "posts"),
	})
}

// ShowCreateForm displays the post creation form
func (h *PostAdminHandler) ShowCreateForm(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Check permission
	if !h.permService.Can(currentUser, "create", "posts") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to create posts",
		})
		return
	}

	// Render form template (or return empty data for SPA)
	ctx.Status(http.StatusOK).JSON(map[string]interface{}{
		"user": currentUser,
	})
}

// ShowEditForm displays the post edit form
func (h *PostAdminHandler) ShowEditForm(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Parse ID
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid post ID",
		})
		return
	}

	// Get post
	post, err := h.postService.GetByID(id)
	if err != nil {
		if err == services.ErrPostNotFound {
			ctx.Status(http.StatusNotFound).JSON(map[string]string{
				"error": "Post not found",
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to fetch post",
		})
		return
	}

	// Check permission
	if !h.permService.Can(currentUser, "update", "posts", id) {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to edit this post",
		})
		return
	}

	// Return post data
	ctx.Status(http.StatusOK).JSON(map[string]interface{}{
		"post": post,
		"user": currentUser,
	})
}

// Store creates a new post
func (h *PostAdminHandler) Store(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Check permission
	if !h.permService.Can(currentUser, "create", "posts") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to create posts",
		})
		return
	}

	// Parse request body
	var createDTO dto.CreatePostDTO
	if err := json.NewDecoder(ctx.Request.Body).Decode(&createDTO); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid request body",
		})
		return
	}

	// Validate
	if err := createDTO.Validate(); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": err.Error(),
		})
		return
	}

	// Create post
	post, err := h.postService.Create(currentUser.ID, createDTO)
	if err != nil {
		if err == services.ErrInvalidInput {
			ctx.Status(http.StatusBadRequest).JSON(map[string]string{
				"error": err.Error(),
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to create post",
		})
		return
	}

	ctx.Status(http.StatusCreated).JSON(post)
}

// Update updates an existing post
func (h *PostAdminHandler) Update(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Parse ID
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid post ID",
		})
		return
	}

	// Check permission
	if !h.permService.Can(currentUser, "update", "posts", id) {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to update this post",
		})
		return
	}

	// Parse request body
	var updateDTO dto.UpdatePostDTO
	if err := json.NewDecoder(ctx.Request.Body).Decode(&updateDTO); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid request body",
		})
		return
	}

	// Validate
	if err := updateDTO.Validate(); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": err.Error(),
		})
		return
	}

	// Update post
	post, err := h.postService.Update(id, currentUser.ID, updateDTO)
	if err != nil {
		if err == services.ErrPostNotFound {
			ctx.Status(http.StatusNotFound).JSON(map[string]string{
				"error": "Post not found",
			})
			return
		}
		if err == services.ErrPermissionDenied {
			ctx.Status(http.StatusForbidden).JSON(map[string]string{
				"error": "You don't have permission to update this post",
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to update post",
		})
		return
	}

	ctx.Status(http.StatusOK).JSON(post)
}

// Destroy deletes a post
func (h *PostAdminHandler) Destroy(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Parse ID
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid post ID",
		})
		return
	}

	// Check permission
	if !h.permService.Can(currentUser, "delete", "posts", id) {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to delete this post",
		})
		return
	}

	// Delete post
	if err := h.postService.Delete(id, currentUser.ID); err != nil {
		if err == services.ErrPostNotFound {
			ctx.Status(http.StatusNotFound).JSON(map[string]string{
				"error": "Post not found",
			})
			return
		}
		if err == services.ErrPermissionDenied {
			ctx.Status(http.StatusForbidden).JSON(map[string]string{
				"error": "You don't have permission to delete this post",
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to delete post",
		})
		return
	}

	ctx.Status(http.StatusNoContent).Send()
}

// Publish publishes a draft post
func (h *PostAdminHandler) Publish(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Parse ID
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid post ID",
		})
		return
	}

	// Check permission
	if !h.permService.Can(currentUser, "publish", "posts", id) {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to publish this post",
		})
		return
	}

	// Publish post
	post, err := h.postService.Publish(id, currentUser.ID)
	if err != nil {
		if err == services.ErrPostNotFound {
			ctx.Status(http.StatusNotFound).JSON(map[string]string{
				"error": "Post not found",
			})
			return
		}
		if err == services.ErrPermissionDenied {
			ctx.Status(http.StatusForbidden).JSON(map[string]string{
				"error": "You don't have permission to publish this post",
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to publish post",
		})
		return
	}

	ctx.Status(http.StatusOK).JSON(post)
}

// BulkAction performs bulk actions on multiple posts
func (h *PostAdminHandler) BulkAction(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Only admins and editors can perform bulk actions
	if !h.permService.Can(currentUser, "bulk", "posts") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to perform bulk actions",
		})
		return
	}

	// Parse request body
	var bulkAction dto.BulkActionDTO
	if err := ctx.BindJSON(&bulkAction); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid request data",
		})
		return
	}

	// Validate
	if err := bulkAction.Validate(); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": err.Error(),
		})
		return
	}

	// Perform action on each post
	successCount := 0
	failureCount := 0
	errors := []string{}

	for _, postID := range bulkAction.PostIDs {
		var err error

		switch bulkAction.Action {
		case "delete":
			err = h.postService.Delete(postID, currentUser.ID)
		case "publish":
			_, err = h.postService.Publish(postID, currentUser.ID)
		case "archive":
			// Archive by updating status
			_, err = h.postService.Update(postID, currentUser.ID, dto.UpdatePostDTO{
				Status: "archived",
			})
		default:
			err = fmt.Errorf("unknown action: %s", bulkAction.Action)
		}

		if err != nil {
			failureCount++
			errors = append(errors, fmt.Sprintf("Post %d: %v", postID, err))
		} else {
			successCount++
		}
	}

	// Return results
	ctx.Status(http.StatusOK).JSON(map[string]interface{}{
		"success_count": successCount,
		"failure_count": failureCount,
		"errors":        errors,
		"message":       fmt.Sprintf("Bulk action completed: %d succeeded, %d failed", successCount, failureCount),
	})
}

// Helper function
func getQueryInt(ctx *router.Context, key string, defaultValue int) int {
	if val := ctx.Query(key); val != "" {
		if i, err := strconv.Atoi(val); err == nil {
			return i
		}
	}
	return defaultValue
}
