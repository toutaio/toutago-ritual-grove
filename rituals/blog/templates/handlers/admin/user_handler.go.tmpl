package admin

import (
	"encoding/json"
	"net/http"
	"strconv"

	"[[.module_path]]/internal/domain"
	"[[.module_path]]/internal/dto"
	"[[.module_path]]/internal/services"
	"github.com/toutaio/toutago-cosan-router"
)

// UserHandler handles admin user management operations
type UserHandler struct {
	userService services.UserService
	permService services.PermissionService
}

// NewUserHandler creates a new UserHandler
func NewUserHandler(userService services.UserService, permService services.PermissionService) *UserHandler {
	return &UserHandler{
		userService: userService,
		permService: permService,
	}
}

// List returns all users with optional filters
func (h *UserHandler) List(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Check permission
	if !h.permService.Can(currentUser, "manage", "users") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to manage users",
		})
		return
	}

	// Parse query parameters
	filters := dto.UserFilters{
		Page:  getQueryInt(ctx, "page", 1),
		Limit: getQueryInt(ctx, "limit", 20),
	}

	if role := ctx.Query("role"); role != "" {
		filters.Role = (*domain.Role)(&role)
	}

	if search := ctx.Query("search"); search != "" {
		filters.Search = &search
	}

	// Get users
	users, total, err := h.userService.List(filters)
	if err != nil {
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to fetch users",
		})
		return
	}

	// Calculate pagination
	totalPages := (total + filters.Limit - 1) / filters.Limit

	// Return response
	ctx.Status(http.StatusOK).JSON(map[string]interface{}{
		"users":       users,
		"total":       total,
		"page":        filters.Page,
		"limit":       filters.Limit,
		"total_pages": totalPages,
	})
}

// GetByID returns a single user by ID
func (h *UserHandler) GetByID(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Check permission
	if !h.permService.Can(currentUser, "manage", "users") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to view user details",
		})
		return
	}

	// Parse ID
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid user ID",
		})
		return
	}

	// Get user
	user, err := h.userService.GetByID(id)
	if err != nil {
		if err == services.ErrUserNotFound {
			ctx.Status(http.StatusNotFound).JSON(map[string]string{
				"error": "User not found",
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to fetch user",
		})
		return
	}

	ctx.Status(http.StatusOK).JSON(user)
}

// Update updates a user
func (h *UserHandler) Update(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Check permission
	if !h.permService.Can(currentUser, "manage", "users") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to update users",
		})
		return
	}

	// Parse ID
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid user ID",
		})
		return
	}

	// Parse request body
	var updateDTO dto.UpdateUserDTO
	if err := json.NewDecoder(ctx.Request.Body).Decode(&updateDTO); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid request body",
		})
		return
	}

	// Validate
	if err := updateDTO.Validate(); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": err.Error(),
		})
		return
	}

	// Update user
	user, err := h.userService.Update(id, updateDTO)
	if err != nil {
		if err == services.ErrUserNotFound {
			ctx.Status(http.StatusNotFound).JSON(map[string]string{
				"error": "User not found",
			})
			return
		}
		if err == services.ErrInvalidEmail || err == services.ErrEmailAlreadyExists {
			ctx.Status(http.StatusBadRequest).JSON(map[string]string{
				"error": err.Error(),
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to update user",
		})
		return
	}

	ctx.Status(http.StatusOK).JSON(user)
}

// Delete deletes a user
func (h *UserHandler) Delete(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Check permission
	if !h.permService.Can(currentUser, "manage", "users") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to delete users",
		})
		return
	}

	// Parse ID
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid user ID",
		})
		return
	}

	// Prevent self-deletion
	if id == currentUser.ID {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "You cannot delete yourself",
		})
		return
	}

	// Delete user
	if err := h.userService.Delete(id); err != nil {
		if err == services.ErrUserNotFound {
			ctx.Status(http.StatusNotFound).JSON(map[string]string{
				"error": "User not found",
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to delete user",
		})
		return
	}

	ctx.Status(http.StatusNoContent).Send()
}

// ChangeRole changes a user's role
func (h *UserHandler) ChangeRole(ctx *router.Context) {
	currentUser := ctx.Get("user").(*domain.User)

	// Check permission
	if !h.permService.Can(currentUser, "manage", "users") {
		ctx.Status(http.StatusForbidden).JSON(map[string]string{
			"error": "You don't have permission to change user roles",
		})
		return
	}

	// Parse ID
	id, err := strconv.ParseInt(ctx.Param("id"), 10, 64)
	if err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid user ID",
		})
		return
	}

	// Parse request body
	var req struct {
		Role string `json:"role"`
	}
	if err := json.NewDecoder(ctx.Request.Body).Decode(&req); err != nil {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid request body",
		})
		return
	}

	// Validate role
	role := domain.Role(req.Role)
	if !role.IsValid() {
		ctx.Status(http.StatusBadRequest).JSON(map[string]string{
			"error": "Invalid role. Must be: admin, editor, author, or reader",
		})
		return
	}

	// Change role
	if err := h.userService.ChangeRole(id, role); err != nil {
		if err == services.ErrUserNotFound {
			ctx.Status(http.StatusNotFound).JSON(map[string]string{
				"error": "User not found",
			})
			return
		}
		ctx.Status(http.StatusInternalServerError).JSON(map[string]string{
			"error": "Failed to change user role",
		})
		return
	}

	ctx.Status(http.StatusOK).JSON(map[string]string{
		"message": "User role updated successfully",
	})
}

// Helper function to get query parameter as int with default
func getQueryInt(ctx *router.Context, key string, defaultValue int) int {
	if val := ctx.Query(key); val != "" {
		if i, err := strconv.Atoi(val); err == nil {
			return i
		}
	}
	return defaultValue
}
